- Q:Alter table 命令支持修改的内容
Alter table:只支持:1.`Alter table tableName Rename TO newName`:修改表名字。 2.`Alter table tableName Rename Column oldColumName TO NewColumnName`.:修改字段名 3.`ALTER TABLE  tableName add column xxx`:增加表字段 4.`ALTER TABLE  tableName Drop Column columnName`:删除表字段（存在主键/唯一键/索引等约束关系时可能删不掉）（#TODO官方文档支持，测试过不支持 - -！）。

```text
1. ALTER TABLE user_account RENAME to 'sss';
2. ALTER TABLE sss  add COLUMN new2;
3. ALTER TABLE sss  add COLUMN new2;
```

- Q:sqlite + alembic 版本管理时.修改字段属性/增加约束关系迁移失败
由于SQLite的alter table 语句不支持去修改字段的属性(比如默认值)/增加字段的约束关系。官方建议是采取`copy and move`的方式。就是先rename旧的表，然后新建一个一样结构的新表(同时增加对应的约束关系).然后把旧表的数据导入到新表.需要手动修改迁移文件：    

```python

"""empty message

Revision ID: 0f5f60fdb2f8
Revises: 71c2b17cd2a0
Create Date: 2022-05-23 09:45:17.127826

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '0f5f60fdb2f8'
down_revision = '71c2b17cd2a0'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    ## 会采取 “copy and move”的策略
    with op.batch_alter_table("user_account") as batch_op:
        batch_op.create_unique_constraint("user_name_unique", ['name'])
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    ## 会采取 “copy and move”的策略，否则会抛出sqlite语法错误
    with op.batch_alter_table("user_account") as batch_op:
        batch_op.drop_constraint('user_name_unique', type_='unique')
    # ### end Alembic commands ###

### 对应的SQL语句
#### 在原有表的基础加入新的约束关系/字段属性 创建一个新的表
CREATE TABLE _alembic_batch_temp (
    ## 旧的建表语句+新的字段属性
);
#### 把旧的数据从旧的表移动到新的表
INSERT INTO _alembic_batch_temp (id) SELECT some_table.id FROM some_table;
#### 把旧的表删除
DROP TABLE some_table;
#### 把新的表改名为旧的表
ALTER TABLE _alembic_batch_temp RENAME TO some_table;


```

- Sqlite锁的类型,以及用的时机
SQLITE的锁状态可以分为以下5种:
a.UNLOCKED:默认状态，此时可能没有进程对数据库进行读和写操作。
b.SHARED:共享锁. 当对sqlite进行读操作时,需要申请该共享锁.共享锁可存在多个,即可以有多个进程同时进行读操作.当一个或多个共享锁处于活动状态时，不允许其他线程或进程写入数据库文件。
c.RESERVED:保留锁.说明有其他进程将要对数据库进行写入，但此时依然允许其他进程获得Share锁。
d.PENDING:挂起锁说明即将有进程要对sqlite进行写操作,并且等待其他SHARE锁释放,此时不会允许有新的其他Share锁申请(与Reserved不同)。
5.EXCLUSIVE:排他锁说明有其他进程正在进行写操作.此时不允许其他程序获得任何状态的锁。



- Q: SQLites xxx.journal 文件的产生,用途.       
当对SQLITE3文件进行写入操作时,SQLITE会首先生成一个临时的**xxx.journal**文件,这是sqlite的回滚日志文件,记录原始未更改的数据库内容。回滚日志是一个普通的磁盘文件，它总是位于与数据库文件相同的目录或文件夹中，并且与数据库文件具有相同的名称，只是添加了一个-journal后缀。回滚日志还记录数据库的初始大小等信息.如果数据库文件增长，就可以在回滚时将其截断回原来的大小。

- Q: SQLIte对数据库读操作时对 xxx.journal文件的操作
当对数据库进行读操作时,主要分为以下几个步骤：
a.打开数据库文件,申请获取一个**SHARED lock**锁,如果获取失败,说明有其他任务正在写入。返回**SQLITE_BUSY**状态。
b.判断是否有**xxx.journal**文件,如果有,则进行回滚操作。即先申请一个pending锁,在申请一个EXCLUSIVE锁.如果获取失败,说明有其他操作正在进行回滚.则返回**SQLITE_BUSY**状态。否则则等待回滚操作完成，然后删除**xxx.journal**文件。然后释放pending锁和EXCLUSIVE锁,并返回一个SHARE锁