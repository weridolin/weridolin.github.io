- Q:Alter table 命令支持修改的内容
Alter table:只支持:1.`Alter table tableName Rename TO newName`:修改表名字。 2.`Alter table tableName Rename Column oldColumName TO NewColumnName`.:修改字段名 3.`ALTER TABLE  tableName add column xxx`:增加表字段 4.`ALTER TABLE  tableName Drop Column columnName`:删除表字段（存在主键/唯一键/索引等约束关系时可能删不掉）（#TODO官方文档支持，测试过不支持 - -！）。

```text
1. ALTER TABLE user_account RENAME to 'sss';
2. ALTER TABLE sss  add COLUMN new2;
3. ALTER TABLE sss  add COLUMN new2;
```

- Q:sqlite + alembic 版本管理时.修改字段属性/增加约束关系迁移失败
由于SQLite的alter table 语句不支持去修改字段的属性(比如默认值)/增加字段的约束关系。官方建议是采取`copy and move`的方式。就是先rename旧的表，然后新建一个一样结构的新表(同时增加对应的约束关系).然后把旧表的数据导入到新表.需要手动修改迁移文件：    

```python

"""empty message

Revision ID: 0f5f60fdb2f8
Revises: 71c2b17cd2a0
Create Date: 2022-05-23 09:45:17.127826

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '0f5f60fdb2f8'
down_revision = '71c2b17cd2a0'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    ## 会采取 “copy and move”的策略
    with op.batch_alter_table("user_account") as batch_op:
        batch_op.create_unique_constraint("user_name_unique", ['name'])
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    ## 会采取 “copy and move”的策略，否则会抛出sqlite语法错误
    with op.batch_alter_table("user_account") as batch_op:
        batch_op.drop_constraint('user_name_unique', type_='unique')
    # ### end Alembic commands ###

### 对应的SQL语句
#### 在原有表的基础加入新的约束关系/字段属性 创建一个新的表
CREATE TABLE _alembic_batch_temp (
    ## 旧的建表语句+新的字段属性
);
#### 把旧的数据从旧的表移动到新的表
INSERT INTO _alembic_batch_temp (id) SELECT some_table.id FROM some_table;
#### 把旧的表删除
DROP TABLE some_table;
#### 把新的表改名为旧的表
ALTER TABLE _alembic_batch_temp RENAME TO some_table;


```

- Sqlite锁的类型,以及用的时机
SQLITE的锁状态可以分为以下5种:
a.UNLOCKED:默认状态，此时可能没有进程对数据库进行读和写操作。
b.SHARED:共享锁. 当对sqlite进行读操作时,需要申请该共享锁.共享锁可存在多个,即可以有多个进程同时进行读操作.当一个或多个共享锁处于活动状态时，不允许其他线程或进程写入数据库文件。
c.RESERVED:保留锁.说明有其他进程将要对数据库进行写入，但此时依然允许其他进程获得Share锁。
d.PENDING:挂起锁说明即将有进程要对sqlite进行写操作,并且等待其他SHARE锁释放,此时不会允许有新的其他Share锁申请(与Reserved不同)。
5.EXCLUSIVE:排他锁说明有其他进程正在进行写操作.此时不允许其他程序获得任何状态的锁。



- Q: SQLites xxx.journal 文件的产生,用途.       
当对SQLITE3文件进行写入操作时,SQLITE会首先生成一个临时的**xxx.journal**文件,这是sqlite的回滚日志文件,记录原始未更改的数据库内容。回滚日志是一个普通的磁盘文件，它总是位于与数据库文件相同的目录或文件夹中，并且与数据库文件具有相同的名称，只是添加了一个-journal后缀。回滚日志还记录数据库的初始大小等信息.如果数据库文件增长，就可以在回滚时将其截断回原来的大小。

- Q: SQLIte对数据库读操作时对 xxx.journal文件的操作
当对数据库进行读操作时,主要分为以下几个步骤：
a.打开数据库文件,申请获取一个**SHARED lock**锁,如果获取失败,说明有其他任务正在写入。返回**SQLITE_BUSY**状态。
b.判断是否有**xxx.journal**文件,如果有,则进行回滚操作。即先申请一个pending锁,在申请一个EXCLUSIVE锁.如果获取失败,说明有其他操作正在进行回滚.则返回**SQLITE_BUSY**状态。否则则等待回滚操作完成，然后删除**xxx.journal**文件。然后释放pending锁和EXCLUSIVE锁,并返回一个SHARE锁


- Q: SQLITE的写流程逻辑:
当对SQLITE进行写入操作时,主要分为以下几个步骤:
a.先获取一个**SHARED**锁(防止有其他进程在进行回滚操作)
b.若获取了share锁后，在获取RESERVED锁,此时其他进程依然可以读取数据,如果无法获取保留锁,说明有其他进程正在写入
c.获取RESERVED锁后，开始创建回滚日志,即xxx.journal文件，将该页的原始内容写入回滚日志。对页面的更改首先保存在内存中，不会写入磁盘。原始数据库文件保持不变，这意味着其他进程可以继续读取数据库。
d.确保了所有回滚日志(xxx.journal)已经写入到磁盘后,会在获取pending锁，知道其他share锁释放完毕,会再去获取EXCLUSIVE排他锁,然后把所有的数据从内容写入到文件中去.然后删除xxx.journal文件，释放pending和exclusive锁.

- Q: Sqlite的存储结构
sqlite是单文件数据库,由多个页面组成,每个数据库文件都有对应100bytes大小的文件头.database的文件头只会在page1第一页出现,但是其他root页面会预留100bytes的空位置。sqlite数据库的头部包括以下内容:
- 1.header-string(16 bytes):sqlite头部格式标记,固定内容为:"SQLite format 3\000"
- 2.The database page size in bytes(2 bytes):sqlite每一页的大小,范围:512~32768,为1的话代表大小为65536.
- 3.File format write version(1 bytes). 1 代表普通, 2代表WAL模式.大于2时表示改数据库既不能读也不能写.
- 4.File format read version(1 bytes). 1 代表普通, 2代表WAL模式.大于2时表示改数据库既不能读也不能写.
- 5.Bytes of unused "reserved" space at the end of each page(1 bytes):每一页保留的字节数,用于拓展用,为偶数且不能小于480(如果不为0的话)
- 6.Maximum embedded payload fraction(1 bytes): Must be 64.
- 7.Minimum embedded payload fraction(1 bytes): Must be 32.
- 8.Leaf payload fraction(1 bytes): Must be 32.
- 9.File change counter(4 bytes):数据库文件改变的次数.在非WAL的模式下,每次修改过,该字节都会加1.当有多个进程同时访问同一个数据库时,可以通过改字段来判断是否修改。
- 10.Size of the database file in pages(4 bytes):
- 11.Page number of the first freelist trunk page(4 bytes):
- 13.Total number of freelist pages(4 bytes):未被使用的页列表，比如删除了一些数据.就会有一些空余的页面.
- 14.The schema cookie(4 bytes):每次修改表结构时,该字段会自动加1
- 15.The schema format number(4 bytes): Supported schema formats are 1, 2, 3, and 4,表格式版本号?
- 16.Default page cache size(4 bytes):缓存页面大小
- 17.The page number of the largest root b-tree page when in auto-vacuum or incremental-vacuum modes, or zero otherwise.
- 18.The database text encoding(4 bytes):数据库文件内容编码：1代表UTF-8. 2代表 UTF-16le. 3代表UTF-16be.
- 19.The "user version" as read and set by the user_version pragma.
- 20.True (non-zero) for incremental-vacuum mode. False (zero) otherwise.
- 21.The "Application ID" set by PRAGMA application_id.
- 22.Reserved for expansion. Must be zero.
- 23.The version-valid-for number.
- 24.SQLITE_VERSION_NUMBER

同理,一个数据库是由多个B-tree组成的——每张表以及每个索引各对应一个B-tree。数据库中每张表或索引都以根页面作为第一页。所有的索引和表的根页面都存储在sqlite_master表中.
![sqlite_master](../sqlite_master.png)

SQlite的存储同样使用的B树,可以分表和索引,表数据的存储使用的是B+树,索引的存储使用的是普通B树.格式如下:   
![sqlite_master](../sqlite_bTree.png)





